---
layout: post
title: "原生JavaScript基础"
date: 2018-06-04
description: "原生JavaScript基础篇"
tag: JS笔记 
--- 
### 一、用typeof判断是否对象的问题，怎么解决判断过程出现的问题
如：
``` typeof a === "object" ```检查a是不是一个对象，这个方法是我们一般的用法，但是在JavaScript中，使用typeof判断的时候，如果判断的是NULL它将视为对象，
```
var a = null
console.log(typeof a === "object")//true
```
返回的结果居然是true，不可能啊应该是false才对啊,我们都知道NULL不是对象。那么问题来了，我们该怎么解决这个出现的问题？我们可以加对一个判断条件看看结果：
```
var a = null
console.log((a!==null)&&(typeof a === "object"))//false
```
哎 这次结果是我们所期待效果了，！但是，当我们需要判断的是一个函数的时候，又出现了对应的问题，我们需求是返回的是true，那么我们继续用条件去判断，
```
var a = null
console.log((a !== null) && ((typeof a === "object") || (typeof a === "function")))//true
```
那么判断的是一个数组的时候，我们也知道数组本身就是一个对象。但是有时候我们的期望值却是false，那么我又该如何？请看下面方案：
```
var a = []
console.log((a !== null) && (typeof a === object) && (toString.call(a)!== "[object Array]"))//false

```
or在jQuery的请看下的方案：
```
console.log((a !== null) && (typeof a === "object") && (! $.isArray(a)));
```
### 二 、以下代码将输出什么到控制台，又是为什么？
```
(function() {  

var a = b = 3;

})();

console.log("a defined? " + (typeof a !== 'undefined'));console.log("b defined? " + (typeof b !== 'undefined'));

```
代码贴出来了，我们首先理解下代码的意思，函数里面首先是这样的``` var a = b = 3 ```是不是感觉是``` var a = b ;var  b = 3  ```分解这样了，js中这样的理解是错误的。我们可能以为结果偶都是false，但是a和b的typeof的结果是不是呢，正确的答案是这样的：<br>
```
var a = b =3;
分解 后：
var a = b;
b =3;
```
不难发现其实b是一个未定义的变量，但是却赋值了。运行后会成为全局的，并不会报错。所以不是严格模式的情况下输出的是``` a defined? false
b defined? true ```,但是我们在控制台直接输出确实这样的结果：``` a defined? true b defined? true ```结果都是真。需要注意的是这个是在不严格的模式下的结果，那么在严格模式下的结果又是怎么样的呢，结果是：```ReferenceError: b is not defined```的运行错误，或者其他的BUG。<br>
### 三、 以下代码将输出什么到控制台，又是为什么？
```
var myObject = {
    foo: "b",
    func: function() { 
    var self = this;
    console.log("outer func:  this.foo = " + this.foo);
    console.log("outer func:  self.foo = " + self.foo);
(function() { 
    console.log("inner func:  this.foo = " + this.foo);
    console.log("inner func:  self.foo = " + self.foo);
 }());
    }
};
myObject.func();

```
输出的结果是：
```
outer func:  this.foo = b
outer func:  self.foo = b
inner func:  this.foo = undefined
inner func:  self.foo = b
```
这个问题涉及到了this了，从得到的结果来看外部函数中的this和self都指向myObject,所以这俩个都能正常的访问和引用foo。<br>
然而在内部函数中，this不在继续指向了myObject，所以就会出现结果为未定义的情况。那么self它指向本地的变量却可以访问得到（在ECMA 5之前，在内部函数<br>
中的this 将指向全局的 window 对象；反之，因为作为ECMA 5，内部函数中的功能this 是未定义的）。
### 四、封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？
这是一个越来越普遍的做法，被许多流行的JavaScript库（jQuery，Node.js等）采用。这种技术创建了一个围绕文件全部内容的闭包，也许是最重要的是，<br>
创建了一个私有的命名空间，从而有助于避免不同JavaScript模块和库之间潜在的名称冲突。<br>
这种技术的另一个特点是，允许一个易于引用的（假设更短的）别名用于全局变量。这通常用于，例如，jQuery插件中。jQuery允许你使jQuery.noConflict()，<br>
来禁用 $ 引用到jQuery命名空间。在完成这项工作之后，你的代码仍然可以使用$ 利用这种闭包技术，如下所示：
```
(function($) { /* jQuery plugin code referencing $ */ } )(jQuery);
```
 未完续.....
