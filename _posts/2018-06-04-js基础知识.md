---
layout: post
title: "原生JavaScript基础"
date: 2018-06-04
description: "原生JavaScript基础篇"
tag: JS笔记 
--- 
### 一、用typeof判断是否对象的问题，怎么解决判断过程出现的问题
如：
``` typeof a === "object" ```检查a是不是一个对象，这个方法是我们一般的用法，但是在JavaScript中，使用typeof判断的时候，如果判断的是NULL它将视为对象，
```
var a = null
console.log(typeof a === "object")//true
```
返回的结果居然是true，不可能啊应该是false才对啊,我们都知道NULL不是对象。那么问题来了，我们该怎么解决这个出现的问题？我们可以加对一个判断条件看看结果：
```
var a = null
console.log((a!==null)&&(typeof a === "object"))//false
```
哎 这次结果是我们所期待效果了，！但是，当我们需要判断的是一个函数的时候，又出现了对应的问题，我们需求是返回的是true，那么我们继续用条件去判断，
```
var a = null
console.log((a !== null) && ((typeof a === "object") || (typeof a === "function")))//true
```
那么判断的是一个数组的时候，我们也知道数组本身就是一个对象。但是有时候我们的期望值却是false，那么我又该如何？请看下面方案：
```
var a = []
console.log((a !== null) && (typeof a === object) && (toString.call(a)!== "[object Array]"))//false

```
or在jQuery的请看下的方案：
```
console.log((a !== null) && (typeof a === "object") && (! $.isArray(a)));
```
### 二 、以下代码将输出什么到控制台，又是为什么？
```
(function() {  

var a = b = 3;

})();

console.log("a defined? " + (typeof a !== 'undefined'));console.log("b defined? " + (typeof b !== 'undefined'));

```
代码贴出来了，我们首先理解下代码的意思，函数里面首先是这样的``` var a = b = 3 ```是不是感觉是``` var a = b ;var  b = 3  ```分解这样了，js中这样的理解是错误的。我们可能以为结果偶都是false，但是a和b的typeof的结果是不是呢，正确的答案是这样的：<br>
```
var a = b =3;
分解 后：
var a = b;
b =3;
```
不难发现其实b是一个未定义的变量，但是却赋值了。运行后会成为全局的，并不会报错。所以不是严格模式的情况下输出的是``` a defined? false
b defined? true ```,但是我们在控制台直接输出确实这样的结果：``` a defined? true b defined? true ```结果都是真。需要注意的是这个是在不严格的模式下的结果，那么在严格模式下的结果又是怎么样的呢，结果是：```ReferenceError: b is not defined```的运行错误，或者其他的BUG。<br>
### 三、 以下代码将输出什么到控制台，又是为什么？
```
var myObject = {
    foo: "b",
    func: function() { 
    var self = this;
    console.log("outer func:  this.foo = " + this.foo);
    console.log("outer func:  self.foo = " + self.foo);
(function() { 
    console.log("inner func:  this.foo = " + this.foo);
    console.log("inner func:  self.foo = " + self.foo);
 }());
    }
};
myObject.func();

```
输出的结果是：
```
outer func:  this.foo = b
outer func:  self.foo = b
inner func:  this.foo = undefined
inner func:  self.foo = b
```
这个问题涉及到了this了，从得到的结果来看外部函数中的this和self都指向myObject,所以这俩个都能正常的访问和引用foo。<br>
然而在内部函数中，this不在继续指向了myObject，所以就会出现结果为未定义的情况。那么self它指向本地的变量却可以访问得到（在ECMA 5之前，在内部函数<br>
中的this 将指向全局的 window 对象；反之，因为作为ECMA 5，内部函数中的功能this 是未定义的）。
### 四、封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？
这是一个越来越普遍的做法，被许多流行的JavaScript库（jQuery，Node.js等）采用。这种技术创建了一个围绕文件全部内容的闭包，也许是最重要的是，<br>
创建了一个私有的命名空间，从而有助于避免不同JavaScript模块和库之间潜在的名称冲突。<br>
这种技术的另一个特点是，允许一个易于引用的（假设更短的）别名用于全局变量。<br>
例如，jQuery插件中。jQuery允许你使jQuery.noConflict(),来禁用 $ 引用到jQuery命名空间。在完成这项工作之后，你的代码仍然可以使用$ 利用这种闭包技术
如下所示：
```
(function($) { /* jQuery plugin code referencing $ */ } )(jQuery);
```
### 五、在JavaScript源文件的开头包含 use strict 有什么意义和好处？
use strict 是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常。通常而言，这是一个很好的做法。
严格模式的一些主要优点包括：<br>

使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。
防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。
消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。这可能会导致许多令人头痛的问题和让人恨不得拔自己头发的bug。在严格模式下，引用 null或未定义的 this 值会抛出错误。
不允许重复的属性名称或参数值。当检测到对象（例如，var object = {foo: "bar", foo: "baz"};）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1){}）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。
使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。
在 delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。
### 六、考虑以下两个函数。它们会返回相同的东西吗？ 为什么相同或为什么不相同？
```
function foo1(){  return {
      bar: "hello"
  };
}
function foo2(){  return
  {
      bar: "hello"
  };
}
console.log(foo1());
console.log(foo2());
```
俩个一样的函数的内容也是一样，感觉结果肯定一致的。但是没想到的是结果居然是：``` 1、Object {bar: "hello"};2、undefined ```
 
后面的居然是undefined，而且如果返回的是undefined的话应该报出错误才是啊。<br>
原因与这样一个事实有关，即分号在JavaScript中是一个可选项（尽管省略它们通常是非常糟糕的形式）。其结果就是，当碰到 foo2()中包含 return语句的代码行（代码行上没有其他任何代码），分号会立即自动插入到返回语句之后。<br>

也不会抛出错误，因为代码的其余部分是完全有效的，即使它没有得到调用或做任何事情（相当于它就是是一个未使用的代码块，定义了等同于字符串 "hello"的属性 bar）。```注意看，第二个return是和它的{}是不在同一行的，```所以出现了这样的情况，按照我正常的代码规范是不会这样出现的，所以也要注意代码规范<br>
 
这种行为也支持放置左括号于JavaScript代码行的末尾，而不是新代码行开头的约定。正如这里所示，这不仅仅只是JavaScript中的一个风格偏好。
### 七、NaN 是什么？它的类型是什么？你如何可靠地测试一个值是否等于 NaN ？
NaN 属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字（例如， "abc" / 4），要么是因为运算的结果非数字（例如，除数为零）。<br>

虽然这看上去很简单，但 NaN 有一些令人惊讶的特点，如果你不知道它们的话，可能会导致令人头痛的bug。<br>

首先，虽然 NaN 意味着“不是数字”，但是它的类型，不管你信不信，是 Number：
```
console.log(typeof NaN === "number");  // "true"
```
此外， NaN 和任何东西比较——甚至是它自己本身！——结果是false：
```
console.log(NaN === NaN); //false
```
一种半可靠的方法来测试一个数字是否等于 NaN，是使用内置函数 isNaN()，但即使使用 isNaN() 依然并非是一个完美的解决方案。<br>

一个更好的解决办法是使用 value !== value，如果值等于NaN，只会产生true。另外，ES6提供了一个新的 Number.isNaN() 函数，这是一个不同的函数，并且比老的全局 isNaN() 函数更可靠。
### 八、下列代码将输出什么？并解释原因。
```
console.log(0.1 + 0.2);
console.log(0.1 + 0.2 == 0.3);

```
一个稍微有点编程基础的回答是：“你不能确定。可能会输出“0.3”和“true”，也可能不会。JavaScript中的数字和浮点精度的处理相同，因此，可能不会总是产生预期的结果。“

以上所提供的例子就是一个演示了这个问题的典型例子。但出人意料的是，它会输出：

```0.30000000000000004 
   false
```
### 九、写函数 isInteger(x) 的可能方法，用于确定x是否是整数。
确定 一个X是否是整数，我们大都觉得这很简单，但是事实上确实很琐碎的。因为ECMAScript 6引入了一个新的```Number.isInteger()  ```函数。在没有引入这个函数之前相比之下会更复杂。但是问题来了，在ECMAScript规格说明中，整数只概念上存在：即，数字值总是存储为浮点值。对于这一个问题，解决方法是：（即使一个非数字的值，如字符串或 null ，被传递给函数）如下：
``` function isInteger(x) { return (x^0) === x; } ```
第二种 解决方法：
``` 
var x =1;function isInteger(x) { return Math.round(x) === x; };isInteger(x)
 
结果：true 

```
请注意 Math.ceil() 和 Math.floor() 在上面的实现中等同于 Math.round()。
第三 种方法：
```
var x =1;function isInteger(x) { return (typeof x === 'number') && (x % 1 === 0)};isInteger(x);
                                
结果：true

```
 未完续.....
